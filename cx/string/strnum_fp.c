#include "string_private.h"
#include "strnum_fppowers.h"
#include "cx/utils/compare.h"

// Modified version of night-shift's fpconv implementation of Fabian Loitsch's Grisu2
// algorithm. Adapted for 32-bit single precision floats in addition to 64-bit
// doubles.
//
// Used under the terms of the Boost Software License
// https://github.com/night-shift/fpconv/blob/master/license

/* Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE. */

#define fracmask_64  0x000FFFFFFFFFFFFFU
#define expmask_64   0x7FF0000000000000U
#define hiddenbit_64 0x0010000000000000U
#define signmask_64  0x8000000000000000U
#define expbias_64   (1023 + 52)

#define fracmask_32  0x007FFFFFU
#define expmask_32   0x7F800000U
#define hiddenbit_32 0x00800000U
#define signmask_32  0x80000000U
#define expbias_32   (127 + 23)

#define absv(n) ((n) < 0 ? -(n) : (n))

static uint64_t tens[] = {
    10000000000000000000U, 1000000000000000000U, 100000000000000000U,
    10000000000000000U, 1000000000000000U, 100000000000000U,
    10000000000000U, 1000000000000U, 100000000000U,
    10000000000U, 1000000000U, 100000000U,
    10000000U, 1000000U, 100000U,
    10000U, 1000U, 100U,
    10U, 1U
};

static _Pure inline uint64_t get_dbits(double d)
{
    union {
        double   dbl;
        uint64_t i;
    } dbl_bits = { d };

    return dbl_bits.i;
}

static _Pure Fp build_fp_64(double d)
{
    uint64_t bits = get_dbits(d);

    Fp fp;
    fp.frac = bits & fracmask_64;
    fp.exp = (bits & expmask_64) >> 52;

    if (fp.exp) {
        fp.frac += hiddenbit_64;
        fp.exp -= expbias_64;
    } else {
        fp.exp = -expbias_64 + 1;
    }

    return fp;
}

static _Pure inline uint32_t get_fbits(float f)
{
    union {
        float    flt;
        uint32_t i;
    } float_bits = { f };

    return float_bits.i;
}

static _Pure Fp build_fp_32(float f)
{
    uint32_t bits = get_fbits(f);

    Fp fp;
    fp.frac = bits & fracmask_32;
    fp.exp = (bits & expmask_32) >> 23;

    if (fp.exp) {
        fp.frac += hiddenbit_32;
        fp.exp -= expbias_32;
    } else {
        fp.exp = -expbias_32 + 1;
    }

    return fp;
}

static void normalize_64(Fp* _Nonnull fp)
{
    while ((fp->frac & hiddenbit_64) == 0) {
        fp->frac <<= 1;
        fp->exp--;
    }

    int shift = 64 - 52 - 1;
    fp->frac <<= shift;
    fp->exp -= shift;
}

static void normalize_32(Fp* _Nonnull fp)
{
    while ((fp->frac & hiddenbit_32) == 0) {
        fp->frac <<= 1;
        fp->exp--;
    }

    int shift = 64 - 23 - 1;
    fp->frac <<= shift;
    fp->exp -= shift;
}

static void get_normalized_boundaries_64(Fp* _Nonnull fp, Fp* _Nonnull lower, Fp* _Nonnull upper)
{
    upper->frac = (fp->frac << 1) + 1;
    upper->exp = fp->exp - 1;

    while ((upper->frac & (hiddenbit_64 << 1)) == 0) {
        upper->frac <<= 1;
        upper->exp--;
    }

    int u_shift = 64 - 52 - 2;

    upper->frac <<= u_shift;
    upper->exp = upper->exp - u_shift;


    int l_shift = fp->frac == hiddenbit_64 ? 2 : 1;

    lower->frac = (fp->frac << l_shift) - 1;
    lower->exp = fp->exp - l_shift;

    lower->frac = lower->frac << (lower->exp - upper->exp);
    lower->exp = upper->exp;
}

static void get_normalized_boundaries_32(Fp* _Nonnull fp, Fp* _Nonnull lower, Fp* _Nonnull upper)
{
    upper->frac = (fp->frac << 1) + 1;
    upper->exp = fp->exp - 1;

    while ((upper->frac & (hiddenbit_32 << 1)) == 0) {
        upper->frac <<= 1;
        upper->exp--;
    }

    int u_shift = 64 - 23 - 2;

    upper->frac <<= u_shift;
    upper->exp = upper->exp - u_shift;


    int l_shift = fp->frac == hiddenbit_32 ? 2 : 1;

    lower->frac = (fp->frac << l_shift) - 1;
    lower->exp = fp->exp - l_shift;


    lower->frac = lower->frac << (lower->exp - upper->exp);
    lower->exp = upper->exp;
}

static Fp multiply(Fp* _Nonnull a, Fp* _Nonnull b)
{
    const uint64_t lomask = 0x00000000FFFFFFFF;

    uint64_t ah_bl = (a->frac >> 32)    * (b->frac & lomask);
    uint64_t al_bh = (a->frac & lomask) * (b->frac >> 32);
    uint64_t al_bl = (a->frac & lomask) * (b->frac & lomask);
    uint64_t ah_bh = (a->frac >> 32)    * (b->frac >> 32);

    uint64_t tmp = (ah_bl & lomask) + (al_bh & lomask) + (al_bl >> 32);
    /* round up */
    tmp += 1U << 31;

    Fp fp = {
        ah_bh + (ah_bl >> 32) + (al_bh >> 32) + (tmp >> 32),
        a->exp + b->exp + 64
    };

    return fp;
}

static void round_digit(uint8* _Nonnull digits, int ndigits, uint64_t delta, uint64_t rem, uint64_t kappa, uint64_t frac)
{
    while (ndigits > 0 && rem < frac && delta - rem >= kappa &&
        (rem + kappa < frac || frac - rem > rem + kappa - frac)) {

        digits[ndigits - 1]--;
        rem += kappa;
    }
}

static int generate_digits(Fp* _Nonnull fp, Fp* _Nonnull upper, Fp* _Nonnull lower, uint8* _Nonnull digits, int* _Nonnull K)
{
    uint64_t wfrac = upper->frac - fp->frac;
    uint64_t delta = upper->frac - lower->frac;

    Fp one;
    one.frac = 1ULL << -upper->exp;
    one.exp = upper->exp;

    uint64_t part1 = upper->frac >> -one.exp;
    uint64_t part2 = upper->frac & (one.frac - 1);

    int idx = 0, kappa = 10;
    uint64_t* divp;
    /* 1000000000 */
    for (divp = tens + 10; kappa > 0; divp++) {
        uint64_t div = *divp;
        unsigned digit = (unsigned)(part1 / div);

        if (digit || idx) {
            digits[idx++] = digit + '0';
        }

        part1 -= digit * div;
        kappa--;

        uint64_t tmp = (part1 << -one.exp) + part2;
        if (tmp <= delta) {
            *K += kappa;
            round_digit(digits, idx, delta, tmp, div << -one.exp, wfrac);

            return idx;
        }
    }

    /* 10 */
    uint64_t* unit = tens + 18;

    while (true) {
        part2 *= 10;
        delta *= 10;
        kappa--;

        unsigned digit = (unsigned)(part2 >> -one.exp);
        if (digit || idx) {
            digits[idx++] = digit + '0';
        }

        part2 &= one.frac - 1;
        if (part2 < delta) {
            *K += kappa;
            round_digit(digits, idx, delta, part2, one.frac, wfrac * *unit);

            return idx;
        }

        unit--;
    }
}

int32 _strnum_grisu2_64(float64 d, _Out_writes_(18) uint8* _Nonnull digits, _Inout_ int32* _Nonnull K)
{
    Fp w = build_fp_64(d);

    Fp lower, upper;
    get_normalized_boundaries_64(&w, &lower, &upper);

    normalize_64(&w);

    int k;
    Fp cp = find_cachedpow10(upper.exp, &k);

    w = multiply(&w, &cp);
    upper = multiply(&upper, &cp);
    lower = multiply(&lower, &cp);

    lower.frac++;
    upper.frac--;

    *K = -k;

    return generate_digits(&w, &upper, &lower, digits, K);
}

int32 _strnum_grisu2_32(float32 f, _Out_writes_(18) uint8* _Nonnull digits, _Inout_ int32* _Nonnull K)
{
    Fp w = build_fp_32(f);

    Fp lower, upper;
    get_normalized_boundaries_32(&w, &lower, &upper);

    normalize_32(&w);

    int k;
    Fp cp = find_cachedpow10(upper.exp, &k);

    w = multiply(&w, &cp);
    upper = multiply(&upper, &cp);
    lower = multiply(&lower, &cp);

    lower.frac++;
    upper.frac--;

    *K = -k;

    return generate_digits(&w, &upper, &lower, digits, K);
}

static int emit_digits(uint8* digits, int ndigits, uint8* dest, int32 K, bool neg)
{
    int exp = absv(K + ndigits - 1);

    /* write plain integer */
    if (K >= 0 && (exp < (ndigits + 7))) {
        memcpy(dest, digits, ndigits);
        memset(dest + ndigits, '0', K);

        return ndigits + K;
    }

    /* write decimal w/o scientific notation */
    if (K < 0 && (K > -7 || exp < 4)) {
        int offset = ndigits - absv(K);
        /* fp < 1.0 -> write leading zero */
        if (offset <= 0) {
            offset = -offset;
            dest[0] = '0';
            dest[1] = '.';
            memset(dest + 2, '0', offset);
            memcpy(dest + offset + 2, digits, ndigits);

            return ndigits + 2 + offset;

        /* fp > 1.0 */
        } else {
            memcpy(dest, digits, offset);
            dest[offset] = '.';
            memcpy(dest + offset + 1, digits + offset, (size_t)ndigits - offset);

            return ndigits + 1;
        }
    }

    /* write decimal w/ scientific notation */
    ndigits = min(ndigits, 18 - neg);

    int idx = 0;
    dest[idx++] = digits[0];

    if (ndigits > 1) {
        dest[idx++] = '.';
        memcpy(dest + idx, digits + 1, (size_t)ndigits - 1);
        idx += ndigits - 1;
    }

    dest[idx++] = 'e';

    char sign = K + ndigits - 1 < 0 ? '-' : '+';
    dest[idx++] = sign;

    int cent = 0;

    if (exp > 99) {
        cent = exp / 100;
        dest[idx++] = cent + '0';
        exp -= cent * 100;
    }
    if (exp > 9) {
        int dec = exp / 10;
        dest[idx++] = dec + '0';
        exp -= dec * 10;

    } else if (cent) {
        dest[idx++] = '0';
    }

    dest[idx++] = exp % 10 + '0';

    return idx;
}

static int filter_special_64(double fp, uint8* dest)
{
    if (fp == 0.0) {
        dest[0] = '0';
        return 1;
    }

    uint64_t bits = get_dbits(fp);

    bool nan = (bits & expmask_64) == expmask_64;

    if (!nan) {
        return 0;
    }

    if (bits & fracmask_64) {
        dest[0] = 'n'; dest[1] = 'a'; dest[2] = 'n';

    } else {
        dest[0] = 'i'; dest[1] = 'n'; dest[2] = 'f';
    }

    return 3;
}

static int filter_special_32(float fp, uint8* dest)
{
    if (fp == 0.0) {
        dest[0] = '0';
        return 1;
    }

    uint32_t bits = get_fbits(fp);

    bool nan = (bits & expmask_32) == expmask_32;

    if (!nan) {
        return 0;
    }

    if (bits & fracmask_32) {
        dest[0] = 'n'; dest[1] = 'a'; dest[2] = 'n';

    } else {
        dest[0] = 'i'; dest[1] = 'n'; dest[2] = 'f';
    }

    return 3;
}

uint32 _strnum_f64toa(float64 d, _Out_writes_(STRNUM_FPBUF) uint8 dest[STRNUM_FPBUF])
{
    uint8 digits[18];

    uint32 str_len = 0;
    bool neg = false;

    if (get_dbits(d) & signmask_64) {
        dest[0] = '-';
        str_len++;
        neg = true;
    }

    int spec = filter_special_64(d, dest + str_len);

    if (spec) {
        return str_len + spec;
    }

    digits[0] = '0';
    int32 K = 0;
    int32 ndigits = _strnum_grisu2_64(d, digits, &K);

    str_len += emit_digits(digits, ndigits, dest + str_len, K, neg);
    dest[str_len] = 0;

    return str_len;
}

uint32 _strnum_f32toa(float32 f, _Out_writes_(STRNUM_FPBUF) uint8 dest[STRNUM_FPBUF])
{
    uint8 digits[18];

    uint32 str_len = 0;
    bool neg = false;

    if (get_fbits(f) & signmask_32) {
        dest[0] = '-';
        str_len++;
        neg = true;
    }

    int spec = filter_special_32(f, dest + str_len);

    if (spec) {
        return str_len + spec;
    }

    int32 K = 0;
    int32 ndigits = _strnum_grisu2_32(f, digits, &K);

    str_len += emit_digits(digits, ndigits, dest + str_len, K, neg);

    dest[str_len] = 0;

    return str_len;
}

bool strFromFloat32(_Inout_ string *out, float32 f)
{
    uint8 buf[STRNUM_FPBUF];
    uint32 buflen;

    buflen = _strnum_f32toa(f, buf);

    strClear(out);

    if (buflen == 0)
        return false;

    uint8 *obuf = strBuffer(out, buflen);
    memcpy(obuf, buf, buflen);

    return true;
}

bool strFromFloat64(_Inout_ string *out, float64 d)
{
    uint8 buf[STRNUM_FPBUF];
    uint32 buflen;

    buflen = _strnum_f64toa(d, buf);

    strClear(out);

    if (buflen == 0)
        return false;

    uint8 *obuf = strBuffer(out, buflen);
    memcpy(obuf, buf, buflen);

    return true;
}
